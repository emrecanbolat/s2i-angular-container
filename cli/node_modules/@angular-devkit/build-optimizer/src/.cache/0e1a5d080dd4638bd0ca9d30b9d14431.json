{"remainingRequest":"/Users/emrecanbolat/s2i-angular-container/cli/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/emrecanbolat/s2i-angular-container/cli/node_modules/@ctrl/ngx-headroom/esm5/ctrl-ngx-headroom.js","dependencies":[{"path":"/Users/emrecanbolat/s2i-angular-container/cli/node_modules/@ctrl/ngx-headroom/esm5/ctrl-ngx-headroom.js","mtime":1518848036000},{"path":"/Users/emrecanbolat/s2i-angular-container/cli/node_modules/cache-loader/dist/cjs.js","mtime":1523583716000},{"path":"/Users/emrecanbolat/s2i-angular-container/cli/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { animate, state, style, transition, trigger } from '@angular/animations';\nimport { Component, EventEmitter, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @param {?=} lastKnownScrollY\n * @param {?=} currentScrollY\n * @param {?=} disable\n * @param {?=} pinStart\n * @param {?=} downTolerance\n * @param {?=} upTolerance\n * @param {?=} state\n * @param {?=} height\n * @return {?}\n */\nfunction shouldUpdate(lastKnownScrollY, currentScrollY, disable, pinStart, downTolerance, upTolerance, state$$1, height) {\n    if (lastKnownScrollY === void 0) {\n        lastKnownScrollY = 0;\n    }\n    if (currentScrollY === void 0) {\n        currentScrollY = 0;\n    }\n    var /** @type {?} */ scrollDirection = currentScrollY >= lastKnownScrollY ? 'down' : 'up';\n    var /** @type {?} */ distanceScrolled = Math.abs(currentScrollY - lastKnownScrollY);\n    // We're disabled\n    if (disable) {\n        return {\n            action: 'none',\n            scrollDirection: scrollDirection,\n            distanceScrolled: distanceScrolled,\n        };\n        // We're at the top and not fixed yet.\n    }\n    else if (currentScrollY <= pinStart && state$$1 !== 'unfixed') {\n        return {\n            action: 'unfix',\n            scrollDirection: scrollDirection,\n            distanceScrolled: distanceScrolled,\n        };\n        // We're unfixed and headed down. Carry on.\n    }\n    else if (currentScrollY <= height &&\n        scrollDirection === 'down' &&\n        state$$1 === 'unfixed') {\n        return {\n            action: 'none',\n            scrollDirection: scrollDirection,\n            distanceScrolled: distanceScrolled,\n        };\n        // We're past the header and scrolling down.\n        // We transition to \"unpinned\" if necessary.\n    }\n    else if (scrollDirection === 'down' &&\n        ['pinned', 'unfixed'].indexOf(state$$1) >= 0 &&\n        currentScrollY > height + pinStart &&\n        distanceScrolled > downTolerance) {\n        return {\n            action: 'unpin',\n            scrollDirection: scrollDirection,\n            distanceScrolled: distanceScrolled,\n        };\n        // We're scrolling up, we transition to \"pinned\"\n    }\n    else if (scrollDirection === 'up' &&\n        distanceScrolled > upTolerance &&\n        ['pinned', 'unfixed'].indexOf(state$$1) < 0) {\n        return {\n            action: 'pin',\n            scrollDirection: scrollDirection,\n            distanceScrolled: distanceScrolled,\n        };\n        // We're scrolling up, and inside the header.\n        // We transition to pin regardless of upTolerance\n    }\n    else if (scrollDirection === 'up' &&\n        currentScrollY <= height &&\n        ['pinned', 'unfixed'].indexOf(state$$1) < 0) {\n        return {\n            action: 'pin',\n            scrollDirection: scrollDirection,\n            distanceScrolled: distanceScrolled,\n        };\n    }\n    else {\n        return {\n            action: 'none',\n            scrollDirection: scrollDirection,\n            distanceScrolled: distanceScrolled,\n        };\n    }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar HeadroomComponent = /*@__PURE__*/ (function () {\n    function HeadroomComponent() {\n        this.wrapperClassName = '';\n        this.innerClassName = '';\n        this.innerStyle = {\n            top: '0',\n            left: '0',\n            right: '0',\n            zIndex: '1',\n            position: 'relative',\n        };\n        /**\n         * pass styles for the wrapper div\n         * (this maintains the components vertical space at the top of the page)\n         */\n        this.wrapperStyle = {};\n        /**\n         * disable pinning and unpinning\n         */\n        this.disable = false;\n        /**\n         * scroll tolerance in px when scrolling up before component is pinned\n         */\n        this.upTolerance = 5;\n        /**\n         * scroll tolerance in px when scrolling down before component is pinned\n         */\n        this.downTolerance = 0;\n        /**\n         * height in px where the header should start and stop pinning.\n         * Useful when you have another element above Headroom\n         */\n        this.pinStart = 0;\n        this.calcHeightOnResize = true;\n        /**\n         * Duration of animation in ms\n         */\n        this.duration = 200;\n        /**\n         * Easing of animation\n         */\n        this.easing = 'ease-in-out';\n        this.pin = new EventEmitter();\n        this.unpin = new EventEmitter();\n        this.unfix = new EventEmitter();\n        this.wrapperHeight = 0;\n        this.currentScrollY = 0;\n        this.lastKnownScrollY = 0;\n        this.scrolled = false;\n        this.resizeTicking = false;\n        this.state = 'unfixed';\n        this.translateY = '0px';\n        this.scrollTicking = false;\n        /**\n         * provide a custom 'parent' element for scroll events.\n         * `parent` should be a function which resolves to the desired element.\n         */\n        this.parent = function () { return window; };\n    }\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.ngOnInit = function () {\n        this.innerStyle.transform = \"translateY(\" + this.translateY + \")\";\n        if (this.disable && !this.disable) {\n            this.handleUnfix();\n            this.parent().removeEventListener('scroll', this.handleScroll);\n            this.parent().removeEventListener('resize', this.handleResize);\n        }\n        else if (!this.disable && this.disable) {\n            this.parent().addEventListener('scroll', this.handleScroll);\n            if (this.calcHeightOnResize) {\n                this.parent().addEventListener('resize', this.handleResize);\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.ngAfterContentInit = function () {\n        var _this = this;\n        this.setHeightOffset();\n        if (!this.disable) {\n            this.parent().addEventListener('scroll', function () { return _this.handleScroll(); });\n            if (this.calcHeightOnResize) {\n                this.parent().addEventListener('resize', function () { return _this.handleResize(); });\n            }\n        }\n        this.wrapperHeight = this.height ? this.height : null;\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.ngOnDestroy = function () {\n        this.parent().removeEventListener('scroll', this.handleScroll);\n        this.parent().removeEventListener('scroll', this.handleScroll);\n        this.parent().removeEventListener('resize', this.handleResize);\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.setHeightOffset = function () {\n        this.height = this.inner.nativeElement.offsetHeight;\n        this.resizeTicking = false;\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.getScrollY = function () {\n        if (this.parent().pageYOffset !== undefined) {\n            return this.parent().pageYOffset;\n        }\n        else if (this.parent().scrollTop !== undefined) {\n            return this.parent().scrollTop;\n        }\n        else {\n            var /** @type {?} */ node = (document.documentElement ||\n                document.body.parentNode ||\n                document.body);\n            return node.scrollTop;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.getViewportHeight = function () {\n        return (this.parent().innerHeight ||\n            document.documentElement.clientHeight ||\n            document.body.clientHeight);\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.getDocumentHeight = function () {\n        var /** @type {?} */ body = document.body;\n        var /** @type {?} */ documentElement = document.documentElement;\n        return Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);\n    };\n    /**\n     * @param {?} elm\n     * @return {?}\n     */\n    HeadroomComponent.prototype.getElementPhysicalHeight = function (elm) {\n        return Math.max(elm.offsetHeight, elm.clientHeight);\n    };\n    /**\n     * @param {?} elm\n     * @return {?}\n     */\n    HeadroomComponent.prototype.getElementHeight = function (elm) {\n        return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.getScrollerPhysicalHeight = function () {\n        var /** @type {?} */ parent = this.parent();\n        return parent === this.parent() || parent === document.body\n            ? this.getViewportHeight()\n            : this.getElementPhysicalHeight(parent);\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.getScrollerHeight = function () {\n        var /** @type {?} */ parent = this.parent();\n        return parent === this.parent() || parent === document.body\n            ? this.getDocumentHeight()\n            : this.getElementHeight(parent);\n    };\n    /**\n     * @param {?} currentScrollY\n     * @return {?}\n     */\n    HeadroomComponent.prototype.isOutOfBound = function (currentScrollY) {\n        var /** @type {?} */ pastTop = currentScrollY < 0;\n        var /** @type {?} */ scrollerPhysicalHeight = this.getScrollerPhysicalHeight();\n        var /** @type {?} */ scrollerHeight = this.getScrollerHeight();\n        var /** @type {?} */ pastBottom = currentScrollY + scrollerPhysicalHeight > scrollerHeight;\n        return pastTop || pastBottom;\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.handleScroll = function () {\n        if (!this.scrollTicking) {\n            this.scrollTicking = true;\n            this.update();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.handleResize = function () {\n        if (!this.resizeTicking) {\n            this.resizeTicking = true;\n            this.setHeightOffset();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.handleUnpin = function () {\n        this.unpin.emit();\n        this.state = 'unpinned';\n        this.innerStyle.position = this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.handlePin = function () {\n        this.pin.emit();\n        this.state = 'pinned';\n        this.innerStyle.position = this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.handleUnfix = function () {\n        this.unfix.emit();\n        this.state = 'unfixed';\n        this.innerStyle.position = this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';\n    };\n    /**\n     * @return {?}\n     */\n    HeadroomComponent.prototype.update = function () {\n        this.currentScrollY = this.getScrollY();\n        if (!this.isOutOfBound(this.currentScrollY)) {\n            var action = shouldUpdate(this.lastKnownScrollY, this.currentScrollY, this.disable, this.pinStart, this.downTolerance, this.upTolerance, this.state, this.height).action;\n            if (action === 'pin') {\n                this.handlePin();\n            }\n            else if (action === 'unpin') {\n                this.handleUnpin();\n            }\n            else if (action === 'unfix') {\n                this.handleUnfix();\n            }\n        }\n        this.lastKnownScrollY = this.currentScrollY;\n        this.scrollTicking = false;\n    };\n    return HeadroomComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar HeadroomModule = /*@__PURE__*/ (function () {\n    function HeadroomModule() {\n    }\n    return HeadroomModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { HeadroomModule, HeadroomComponent };\n//# sourceMappingURL=ctrl-ngx-headroom.js.map\n",null]}