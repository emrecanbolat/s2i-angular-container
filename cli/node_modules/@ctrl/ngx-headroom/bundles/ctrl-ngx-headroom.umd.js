(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/animations'), require('@angular/core'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/animations', '@angular/core', '@angular/common'], factory) :
	(factory((global.ctrl = global.ctrl || {}, global.ctrl['ngx-headroom'] = {}),global.ng.animations,global.ng.core,global.ng.common));
}(this, (function (exports,animations,core,common) { 'use strict';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?=} lastKnownScrollY
 * @param {?=} currentScrollY
 * @param {?=} disable
 * @param {?=} pinStart
 * @param {?=} downTolerance
 * @param {?=} upTolerance
 * @param {?=} state
 * @param {?=} height
 * @return {?}
 */
function shouldUpdate(lastKnownScrollY, currentScrollY, disable, pinStart, downTolerance, upTolerance, state$$1, height) {
    if (lastKnownScrollY === void 0) { lastKnownScrollY = 0; }
    if (currentScrollY === void 0) { currentScrollY = 0; }
    var /** @type {?} */ scrollDirection = currentScrollY >= lastKnownScrollY ? 'down' : 'up';
    var /** @type {?} */ distanceScrolled = Math.abs(currentScrollY - lastKnownScrollY);
    // We're disabled
    if (disable) {
        return {
            action: 'none',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
        // We're at the top and not fixed yet.
    }
    else if (currentScrollY <= pinStart && state$$1 !== 'unfixed') {
        return {
            action: 'unfix',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
        // We're unfixed and headed down. Carry on.
    }
    else if (currentScrollY <= height &&
        scrollDirection === 'down' &&
        state$$1 === 'unfixed') {
        return {
            action: 'none',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
        // We're past the header and scrolling down.
        // We transition to "unpinned" if necessary.
    }
    else if (scrollDirection === 'down' &&
        ['pinned', 'unfixed'].indexOf(state$$1) >= 0 &&
        currentScrollY > height + pinStart &&
        distanceScrolled > downTolerance) {
        return {
            action: 'unpin',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
        // We're scrolling up, we transition to "pinned"
    }
    else if (scrollDirection === 'up' &&
        distanceScrolled > upTolerance &&
        ['pinned', 'unfixed'].indexOf(state$$1) < 0) {
        return {
            action: 'pin',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
        // We're scrolling up, and inside the header.
        // We transition to pin regardless of upTolerance
    }
    else if (scrollDirection === 'up' &&
        currentScrollY <= height &&
        ['pinned', 'unfixed'].indexOf(state$$1) < 0) {
        return {
            action: 'pin',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
    }
    else {
        return {
            action: 'none',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
    }
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HeadroomComponent = /** @class */ (function () {
    function HeadroomComponent() {
        this.wrapperClassName = '';
        this.innerClassName = '';
        this.innerStyle = {
            top: '0',
            left: '0',
            right: '0',
            zIndex: '1',
            position: 'relative',
        };
        /**
         * pass styles for the wrapper div
         * (this maintains the components vertical space at the top of the page)
         */
        this.wrapperStyle = {};
        /**
         * disable pinning and unpinning
         */
        this.disable = false;
        /**
         * scroll tolerance in px when scrolling up before component is pinned
         */
        this.upTolerance = 5;
        /**
         * scroll tolerance in px when scrolling down before component is pinned
         */
        this.downTolerance = 0;
        /**
         * height in px where the header should start and stop pinning.
         * Useful when you have another element above Headroom
         */
        this.pinStart = 0;
        this.calcHeightOnResize = true;
        /**
         * Duration of animation in ms
         */
        this.duration = 200;
        /**
         * Easing of animation
         */
        this.easing = 'ease-in-out';
        this.pin = new core.EventEmitter();
        this.unpin = new core.EventEmitter();
        this.unfix = new core.EventEmitter();
        this.wrapperHeight = 0;
        this.currentScrollY = 0;
        this.lastKnownScrollY = 0;
        this.scrolled = false;
        this.resizeTicking = false;
        this.state = 'unfixed';
        this.translateY = '0px';
        this.scrollTicking = false;
        /**
         * provide a custom 'parent' element for scroll events.
         * `parent` should be a function which resolves to the desired element.
         */
        this.parent = function () { return window; };
    }
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.ngOnInit = function () {
        this.innerStyle.transform = "translateY(" + this.translateY + ")";
        if (this.disable && !this.disable) {
            this.handleUnfix();
            this.parent().removeEventListener('scroll', this.handleScroll);
            this.parent().removeEventListener('resize', this.handleResize);
        }
        else if (!this.disable && this.disable) {
            this.parent().addEventListener('scroll', this.handleScroll);
            if (this.calcHeightOnResize) {
                this.parent().addEventListener('resize', this.handleResize);
            }
        }
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.setHeightOffset();
        if (!this.disable) {
            this.parent().addEventListener('scroll', function () { return _this.handleScroll(); });
            if (this.calcHeightOnResize) {
                this.parent().addEventListener('resize', function () { return _this.handleResize(); });
            }
        }
        this.wrapperHeight = this.height ? this.height : null;
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.ngOnDestroy = function () {
        this.parent().removeEventListener('scroll', this.handleScroll);
        this.parent().removeEventListener('scroll', this.handleScroll);
        this.parent().removeEventListener('resize', this.handleResize);
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.setHeightOffset = function () {
        this.height = this.inner.nativeElement.offsetHeight;
        this.resizeTicking = false;
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.getScrollY = function () {
        if (this.parent().pageYOffset !== undefined) {
            return this.parent().pageYOffset;
        }
        else if (this.parent().scrollTop !== undefined) {
            return this.parent().scrollTop;
        }
        else {
            var /** @type {?} */ node = (document.documentElement ||
                document.body.parentNode ||
                document.body);
            return node.scrollTop;
        }
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.getViewportHeight = function () {
        return (this.parent().innerHeight ||
            document.documentElement.clientHeight ||
            document.body.clientHeight);
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.getDocumentHeight = function () {
        var /** @type {?} */ body = document.body;
        var /** @type {?} */ documentElement = document.documentElement;
        return Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);
    };
    /**
     * @param {?} elm
     * @return {?}
     */
    HeadroomComponent.prototype.getElementPhysicalHeight = function (elm) {
        return Math.max(elm.offsetHeight, elm.clientHeight);
    };
    /**
     * @param {?} elm
     * @return {?}
     */
    HeadroomComponent.prototype.getElementHeight = function (elm) {
        return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.getScrollerPhysicalHeight = function () {
        var /** @type {?} */ parent = this.parent();
        return parent === this.parent() || parent === document.body
            ? this.getViewportHeight()
            : this.getElementPhysicalHeight(parent);
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.getScrollerHeight = function () {
        var /** @type {?} */ parent = this.parent();
        return parent === this.parent() || parent === document.body
            ? this.getDocumentHeight()
            : this.getElementHeight(parent);
    };
    /**
     * @param {?} currentScrollY
     * @return {?}
     */
    HeadroomComponent.prototype.isOutOfBound = function (currentScrollY) {
        var /** @type {?} */ pastTop = currentScrollY < 0;
        var /** @type {?} */ scrollerPhysicalHeight = this.getScrollerPhysicalHeight();
        var /** @type {?} */ scrollerHeight = this.getScrollerHeight();
        var /** @type {?} */ pastBottom = currentScrollY + scrollerPhysicalHeight > scrollerHeight;
        return pastTop || pastBottom;
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.handleScroll = function () {
        if (!this.scrollTicking) {
            this.scrollTicking = true;
            this.update();
        }
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.handleResize = function () {
        if (!this.resizeTicking) {
            this.resizeTicking = true;
            this.setHeightOffset();
        }
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.handleUnpin = function () {
        this.unpin.emit();
        this.state = 'unpinned';
        this.innerStyle.position = this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.handlePin = function () {
        this.pin.emit();
        this.state = 'pinned';
        this.innerStyle.position = this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.handleUnfix = function () {
        this.unfix.emit();
        this.state = 'unfixed';
        this.innerStyle.position = this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    };
    /**
     * @return {?}
     */
    HeadroomComponent.prototype.update = function () {
        this.currentScrollY = this.getScrollY();
        if (!this.isOutOfBound(this.currentScrollY)) {
            var action = shouldUpdate(this.lastKnownScrollY, this.currentScrollY, this.disable, this.pinStart, this.downTolerance, this.upTolerance, this.state, this.height).action;
            if (action === 'pin') {
                this.handlePin();
            }
            else if (action === 'unpin') {
                this.handleUnpin();
            }
            else if (action === 'unfix') {
                this.handleUnfix();
            }
        }
        this.lastKnownScrollY = this.currentScrollY;
        this.scrollTicking = false;
    };
    return HeadroomComponent;
}());
HeadroomComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-headroom',
                template: "\n  <div [ngStyle]=\"wrapperStyle\"\n    [style.height.px]=\"wrapperHeight\"\n    class=\"headroom-wrapper {{ wrapperClassName }}\"\n  >\n    <div #ref\n      [ngStyle]=\"innerStyle\"\n      [@headroom]=\"{\n        value: state,\n        params: {\n          duration: duration,\n          easing: easing\n        }\n      }\"\n      [class]=\"innerClassName\"\n      [class.headroom]=\"true\"\n      [class.headroom--unfixed]=\"state === 'unfixed'\"\n      [class.headroom--unpinned]=\"state === 'unpinned'\"\n      [class.headroom--pinned]=\"state === 'pinned'\"\n      [class.headroom--unfixed]=\"state === 'unfixed'\"\n    >\n      <ng-content></ng-content>\n    </div>\n  </div>\n  ",
                animations: [
                    animations.trigger('headroom', [
                        animations.state('unfixed', animations.style({
                            transform: 'translateY(0)',
                        })),
                        animations.state('unpinned', animations.style({
                            transform: 'translateY(-100%)',
                        })),
                        animations.state('pinned', animations.style({
                            transform: 'translateY(0px)',
                        })),
                        animations.transition('unpinned <=> pinned', animations.animate('{{ duration }}ms {{ easing }}')),
                    ]),
                ],
                preserveWhitespaces: false,
            },] },
];
/** @nocollapse */
HeadroomComponent.ctorParameters = function () { return []; };
HeadroomComponent.propDecorators = {
    "wrapperClassName": [{ type: core.Input },],
    "innerClassName": [{ type: core.Input },],
    "innerStyle": [{ type: core.Input },],
    "wrapperStyle": [{ type: core.Input },],
    "disable": [{ type: core.Input },],
    "upTolerance": [{ type: core.Input },],
    "downTolerance": [{ type: core.Input },],
    "pinStart": [{ type: core.Input },],
    "calcHeightOnResize": [{ type: core.Input },],
    "duration": [{ type: core.Input },],
    "easing": [{ type: core.Input },],
    "pin": [{ type: core.Output },],
    "unpin": [{ type: core.Output },],
    "unfix": [{ type: core.Output },],
    "inner": [{ type: core.ViewChild, args: ['ref',] },],
    "parent": [{ type: core.Input },],
};
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HeadroomModule = /** @class */ (function () {
    function HeadroomModule() {
    }
    return HeadroomModule;
}());
HeadroomModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [common.CommonModule],
                exports: [HeadroomComponent],
                declarations: [HeadroomComponent],
            },] },
];
/** @nocollapse */
HeadroomModule.ctorParameters = function () { return []; };

exports.HeadroomModule = HeadroomModule;
exports.HeadroomComponent = HeadroomComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ctrl-ngx-headroom.umd.js.map
