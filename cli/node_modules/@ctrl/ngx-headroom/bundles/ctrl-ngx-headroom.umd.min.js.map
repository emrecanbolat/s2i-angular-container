{
  "version": 3,
  "file": "ctrl-ngx-headroom.umd.min.js",
  "sources": [
    "ng://@ctrl/ngx-headroom/out/headroom.component.ts",
    "ng://@ctrl/ngx-headroom/out/shouldUpdate.ts"
  ],
  "sourcesContent": [
    "import {\n  animate,\n  state,\n  style,\n  transition,\n  trigger,\n} from '@angular/animations';\nimport {\n  AfterContentInit,\n  Component,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  OnInit,\n  Output,\n  ViewChild,\n} from '@angular/core';\n\nimport shouldUpdate from './shouldUpdate';\n\n@Component({\n  selector: 'ngx-headroom',\n  template: `\n  <div [ngStyle]=\"wrapperStyle\"\n    [style.height.px]=\"wrapperHeight\"\n    class=\"headroom-wrapper {{ wrapperClassName }}\"\n  >\n    <div #ref\n      [ngStyle]=\"innerStyle\"\n      [@headroom]=\"{\n        value: state,\n        params: {\n          duration: duration,\n          easing: easing\n        }\n      }\"\n      [class]=\"innerClassName\"\n      [class.headroom]=\"true\"\n      [class.headroom--unfixed]=\"state === 'unfixed'\"\n      [class.headroom--unpinned]=\"state === 'unpinned'\"\n      [class.headroom--pinned]=\"state === 'pinned'\"\n      [class.headroom--unfixed]=\"state === 'unfixed'\"\n    >\n      <ng-content></ng-content>\n    </div>\n  </div>\n  `,\n  animations: [\n    trigger('headroom', [\n      state('unfixed', style({\n        transform: 'translateY(0)',\n      })),\n      state('unpinned', style({\n        transform: 'translateY(-100%)',\n      })),\n      state('pinned', style({\n        transform: 'translateY(0px)',\n      })),\n      transition('unpinned <=> pinned', animate('{{ duration }}ms {{ easing }}')),\n    ]),\n  ],\n  preserveWhitespaces: false,\n})\nexport class HeadroomComponent implements OnInit, AfterContentInit, OnDestroy {\n  @Input() wrapperClassName = '';\n  @Input() innerClassName = '';\n  @Input() innerStyle: any = {\n    top: '0',\n    left: '0',\n    right: '0',\n    zIndex: '1',\n    position: 'relative',\n  };\n  /**\n   * pass styles for the wrapper div\n   * (this maintains the components vertical space at the top of the page)\n   */\n  @Input() wrapperStyle: any = {};\n  /** disable pinning and unpinning */\n  @Input() disable = false;\n  /** scroll tolerance in px when scrolling up before component is pinned */\n  @Input() upTolerance = 5;\n  /** scroll tolerance in px when scrolling down before component is pinned */\n  @Input() downTolerance = 0;\n  /**\n   * height in px where the header should start and stop pinning.\n   * Useful when you have another element above Headroom\n   */\n  @Input() pinStart = 0;\n  @Input() calcHeightOnResize = true;\n  /** Duration of animation in ms */\n  @Input() duration = 200;\n  /** Easing of animation */\n  @Input() easing = 'ease-in-out';\n  @Output() pin = new EventEmitter();\n  @Output() unpin = new EventEmitter();\n  @Output() unfix = new EventEmitter();\n  @ViewChild('ref') inner: ElementRef;\n  wrapperHeight = 0;\n  currentScrollY = 0;\n  lastKnownScrollY = 0;\n  scrolled = false;\n  resizeTicking = false;\n  state = 'unfixed';\n  translateY = '0px';\n  height: number;\n  scrollTicking = false;\n  /**\n   * provide a custom 'parent' element for scroll events.\n   * `parent` should be a function which resolves to the desired element.\n   */\n  @Input() parent: () => any = () => window;\n\n  ngOnInit() {\n    this.innerStyle.transform = `translateY(${this.translateY})`;\n\n    if (this.disable && !this.disable) {\n      this.handleUnfix();\n      this.parent().removeEventListener('scroll', this.handleScroll);\n      this.parent().removeEventListener('resize', this.handleResize);\n    } else if (!this.disable && this.disable) {\n      this.parent().addEventListener('scroll', this.handleScroll);\n\n      if (this.calcHeightOnResize) {\n        this.parent().addEventListener('resize', this.handleResize);\n      }\n    }\n  }\n  ngAfterContentInit() {\n    this.setHeightOffset();\n    if (!this.disable) {\n      this.parent().addEventListener('scroll', () => this.handleScroll());\n\n      if (this.calcHeightOnResize) {\n        this.parent().addEventListener('resize', () => this.handleResize());\n      }\n    }\n    this.wrapperHeight = this.height ? this.height : null;\n  }\n  ngOnDestroy() {\n    this.parent().removeEventListener('scroll', this.handleScroll);\n    this.parent().removeEventListener('scroll', this.handleScroll);\n    this.parent().removeEventListener('resize', this.handleResize);\n  }\n  setHeightOffset() {\n    this.height = this.inner.nativeElement.offsetHeight;\n    this.resizeTicking = false;\n  }\n\n  getScrollY() {\n    if (this.parent().pageYOffset !== undefined) {\n      return this.parent().pageYOffset;\n    } else if (this.parent().scrollTop !== undefined) {\n      return this.parent().scrollTop;\n    } else {\n      const node: any = (\n        document.documentElement ||\n        document.body.parentNode ||\n        document.body\n      );\n      return node.scrollTop;\n    }\n  }\n  getViewportHeight() {\n    return (\n      this.parent().innerHeight ||\n      document.documentElement.clientHeight ||\n      document.body.clientHeight\n    );\n  }\n  getDocumentHeight() {\n    const body = document.body;\n    const documentElement = document.documentElement;\n\n    return Math.max(\n      body.scrollHeight,\n      documentElement.scrollHeight,\n      body.offsetHeight,\n      documentElement.offsetHeight,\n      body.clientHeight,\n      documentElement.clientHeight,\n    );\n  }\n  getElementPhysicalHeight(elm: any) {\n    return Math.max(elm.offsetHeight, elm.clientHeight);\n  }\n  getElementHeight(elm: any) {\n    return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);\n  }\n  getScrollerPhysicalHeight() {\n    const parent = this.parent();\n\n    return parent === this.parent() || parent === document.body\n      ? this.getViewportHeight()\n      : this.getElementPhysicalHeight(parent);\n  }\n  getScrollerHeight() {\n    const parent = this.parent();\n\n    return parent === this.parent() || parent === document.body\n      ? this.getDocumentHeight()\n      : this.getElementHeight(parent);\n  }\n  isOutOfBound(currentScrollY) {\n    const pastTop = currentScrollY < 0;\n\n    const scrollerPhysicalHeight = this.getScrollerPhysicalHeight();\n    const scrollerHeight = this.getScrollerHeight();\n\n    const pastBottom = currentScrollY + scrollerPhysicalHeight > scrollerHeight;\n\n    return pastTop || pastBottom;\n  }\n  handleScroll() {\n    if (!this.scrollTicking) {\n      this.scrollTicking = true;\n      this.update();\n    }\n  }\n  handleResize() {\n    if (!this.resizeTicking) {\n      this.resizeTicking = true;\n      this.setHeightOffset();\n    }\n  }\n  handleUnpin() {\n    this.unpin.emit();\n    this.state = 'unpinned';\n    this.innerStyle.position = this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';\n  }\n  handlePin() {\n    this.pin.emit();\n    this.state = 'pinned';\n    this.innerStyle.position = this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';\n  }\n  handleUnfix() {\n    this.unfix.emit();\n    this.state = 'unfixed';\n    this.innerStyle.position = this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';\n  }\n  update() {\n    this.currentScrollY = this.getScrollY();\n\n    if (!this.isOutOfBound(this.currentScrollY)) {\n      const { action } = shouldUpdate(\n        this.lastKnownScrollY,\n        this.currentScrollY,\n        this.disable,\n        this.pinStart,\n        this.downTolerance,\n        this.upTolerance,\n        this.state,\n        this.height,\n      );\n\n      if (action === 'pin') {\n        this.handlePin();\n      } else if (action === 'unpin') {\n        this.handleUnpin();\n      } else if (action === 'unfix') {\n        this.handleUnfix();\n      }\n    }\n\n    this.lastKnownScrollY = this.currentScrollY;\n    this.scrollTicking = false;\n  }\n}\n",
    "export default function(\n  lastKnownScrollY = 0,\n  currentScrollY = 0,\n  disable?: boolean,\n  pinStart?: number,\n  downTolerance?: number,\n  upTolerance?: number,\n  state?: string,\n  height?: number,\n) {\n  const scrollDirection = currentScrollY >= lastKnownScrollY ? 'down' : 'up';\n  const distanceScrolled = Math.abs(currentScrollY - lastKnownScrollY);\n\n  // We're disabled\n  if (disable) {\n    return {\n      action: 'none',\n      scrollDirection,\n      distanceScrolled,\n    };\n    // We're at the top and not fixed yet.\n  } else if (currentScrollY <= pinStart && state !== 'unfixed') {\n    return {\n      action: 'unfix',\n      scrollDirection,\n      distanceScrolled,\n    };\n    // We're unfixed and headed down. Carry on.\n  } else if (\n    currentScrollY <= height &&\n    scrollDirection === 'down' &&\n    state === 'unfixed'\n  ) {\n    return {\n      action: 'none',\n      scrollDirection,\n      distanceScrolled,\n    };\n    // We're past the header and scrolling down.\n    // We transition to \"unpinned\" if necessary.\n  } else if (\n    scrollDirection === 'down' &&\n    ['pinned', 'unfixed'].indexOf(state) >= 0 &&\n    currentScrollY > height + pinStart &&\n    distanceScrolled > downTolerance\n  ) {\n    return {\n      action: 'unpin',\n      scrollDirection,\n      distanceScrolled,\n    };\n    // We're scrolling up, we transition to \"pinned\"\n  } else if (\n    scrollDirection === 'up' &&\n    distanceScrolled > upTolerance &&\n    ['pinned', 'unfixed'].indexOf(state) < 0\n  ) {\n    return {\n      action: 'pin',\n      scrollDirection,\n      distanceScrolled,\n    };\n    // We're scrolling up, and inside the header.\n    // We transition to pin regardless of upTolerance\n  } else if (\n    scrollDirection === 'up' &&\n    currentScrollY <= height &&\n    ['pinned', 'unfixed'].indexOf(state) < 0\n  ) {\n    return {\n      action: 'pin',\n      scrollDirection,\n      distanceScrolled,\n    };\n  } else {\n    return {\n      action: 'none',\n      scrollDirection,\n      distanceScrolled,\n    };\n  }\n}\n"
  ],
  "names": [
    "HeadroomComponent",
    "this",
    "wrapperClassName",
    "innerClassName",
    "innerStyle",
    "top",
    "left",
    "right",
    "zIndex",
    "position",
    "wrapperStyle",
    "disable",
    "upTolerance",
    "downTolerance",
    "pinStart",
    "calcHeightOnResize",
    "duration",
    "easing",
    "pin",
    "EventEmitter",
    "unpin",
    "unfix",
    "wrapperHeight",
    "currentScrollY",
    "lastKnownScrollY",
    "scrolled",
    "resizeTicking",
    "state",
    "translateY",
    "scrollTicking",
    "parent",
    "window",
    "prototype",
    "ngOnInit",
    "transform",
    "handleUnfix",
    "removeEventListener",
    "handleScroll",
    "handleResize",
    "addEventListener",
    "ngAfterContentInit",
    "_this",
    "setHeightOffset",
    "height",
    "ngOnDestroy",
    "inner",
    "nativeElement",
    "offsetHeight",
    "getScrollY",
    "pageYOffset",
    "undefined",
    "scrollTop",
    "document",
    "documentElement",
    "body",
    "parentNode",
    "getViewportHeight",
    "innerHeight",
    "clientHeight",
    "getDocumentHeight",
    "Math",
    "max",
    "scrollHeight",
    "getElementPhysicalHeight",
    "elm",
    "getElementHeight",
    "getScrollerPhysicalHeight",
    "getScrollerHeight",
    "isOutOfBound",
    "pastTop",
    "scrollerPhysicalHeight",
    "scrollerHeight",
    "update",
    "handleUnpin",
    "emit",
    "handlePin",
    "action",
    "scrollDirection",
    "distanceScrolled",
    "state$$1",
    "indexOf",
    "shouldUpdate",
    "decorators",
    "type",
    "Component",
    "args",
    "Input",
    "Output",
    "ViewChild",
    "HeadroomModule",
    "NgModule",
    "imports",
    "CommonModule",
    "exports",
    "declarations",
    "ctorParameters"
  ],
  "mappings": "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"
}
