import { animate, state, style, transition, trigger } from '@angular/animations';
import { Component, EventEmitter, Input, Output, ViewChild, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?=} lastKnownScrollY
 * @param {?=} currentScrollY
 * @param {?=} disable
 * @param {?=} pinStart
 * @param {?=} downTolerance
 * @param {?=} upTolerance
 * @param {?=} state
 * @param {?=} height
 * @return {?}
 */
function shouldUpdate (lastKnownScrollY = 0, currentScrollY = 0, disable, pinStart, downTolerance, upTolerance, state$$1, height) {
    const /** @type {?} */ scrollDirection = currentScrollY >= lastKnownScrollY ? 'down' : 'up';
    const /** @type {?} */ distanceScrolled = Math.abs(currentScrollY - lastKnownScrollY);
    // We're disabled
    if (disable) {
        return {
            action: 'none',
            scrollDirection,
            distanceScrolled,
        };
        // We're at the top and not fixed yet.
    }
    else if (currentScrollY <= pinStart && state$$1 !== 'unfixed') {
        return {
            action: 'unfix',
            scrollDirection,
            distanceScrolled,
        };
        // We're unfixed and headed down. Carry on.
    }
    else if (currentScrollY <= height &&
        scrollDirection === 'down' &&
        state$$1 === 'unfixed') {
        return {
            action: 'none',
            scrollDirection,
            distanceScrolled,
        };
        // We're past the header and scrolling down.
        // We transition to "unpinned" if necessary.
    }
    else if (scrollDirection === 'down' &&
        ['pinned', 'unfixed'].indexOf(state$$1) >= 0 &&
        currentScrollY > height + pinStart &&
        distanceScrolled > downTolerance) {
        return {
            action: 'unpin',
            scrollDirection,
            distanceScrolled,
        };
        // We're scrolling up, we transition to "pinned"
    }
    else if (scrollDirection === 'up' &&
        distanceScrolled > upTolerance &&
        ['pinned', 'unfixed'].indexOf(state$$1) < 0) {
        return {
            action: 'pin',
            scrollDirection,
            distanceScrolled,
        };
        // We're scrolling up, and inside the header.
        // We transition to pin regardless of upTolerance
    }
    else if (scrollDirection === 'up' &&
        currentScrollY <= height &&
        ['pinned', 'unfixed'].indexOf(state$$1) < 0) {
        return {
            action: 'pin',
            scrollDirection,
            distanceScrolled,
        };
    }
    else {
        return {
            action: 'none',
            scrollDirection,
            distanceScrolled,
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class HeadroomComponent {
    constructor() {
        this.wrapperClassName = '';
        this.innerClassName = '';
        this.innerStyle = {
            top: '0',
            left: '0',
            right: '0',
            zIndex: '1',
            position: 'relative',
        };
        /**
         * pass styles for the wrapper div
         * (this maintains the components vertical space at the top of the page)
         */
        this.wrapperStyle = {};
        /**
         * disable pinning and unpinning
         */
        this.disable = false;
        /**
         * scroll tolerance in px when scrolling up before component is pinned
         */
        this.upTolerance = 5;
        /**
         * scroll tolerance in px when scrolling down before component is pinned
         */
        this.downTolerance = 0;
        /**
         * height in px where the header should start and stop pinning.
         * Useful when you have another element above Headroom
         */
        this.pinStart = 0;
        this.calcHeightOnResize = true;
        /**
         * Duration of animation in ms
         */
        this.duration = 200;
        /**
         * Easing of animation
         */
        this.easing = 'ease-in-out';
        this.pin = new EventEmitter();
        this.unpin = new EventEmitter();
        this.unfix = new EventEmitter();
        this.wrapperHeight = 0;
        this.currentScrollY = 0;
        this.lastKnownScrollY = 0;
        this.scrolled = false;
        this.resizeTicking = false;
        this.state = 'unfixed';
        this.translateY = '0px';
        this.scrollTicking = false;
        /**
         * provide a custom 'parent' element for scroll events.
         * `parent` should be a function which resolves to the desired element.
         */
        this.parent = () => window;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.innerStyle.transform = `translateY(${this.translateY})`;
        if (this.disable && !this.disable) {
            this.handleUnfix();
            this.parent().removeEventListener('scroll', this.handleScroll);
            this.parent().removeEventListener('resize', this.handleResize);
        }
        else if (!this.disable && this.disable) {
            this.parent().addEventListener('scroll', this.handleScroll);
            if (this.calcHeightOnResize) {
                this.parent().addEventListener('resize', this.handleResize);
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setHeightOffset();
        if (!this.disable) {
            this.parent().addEventListener('scroll', () => this.handleScroll());
            if (this.calcHeightOnResize) {
                this.parent().addEventListener('resize', () => this.handleResize());
            }
        }
        this.wrapperHeight = this.height ? this.height : null;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.parent().removeEventListener('scroll', this.handleScroll);
        this.parent().removeEventListener('scroll', this.handleScroll);
        this.parent().removeEventListener('resize', this.handleResize);
    }
    /**
     * @return {?}
     */
    setHeightOffset() {
        this.height = this.inner.nativeElement.offsetHeight;
        this.resizeTicking = false;
    }
    /**
     * @return {?}
     */
    getScrollY() {
        if (this.parent().pageYOffset !== undefined) {
            return this.parent().pageYOffset;
        }
        else if (this.parent().scrollTop !== undefined) {
            return this.parent().scrollTop;
        }
        else {
            const /** @type {?} */ node = (document.documentElement ||
                document.body.parentNode ||
                document.body);
            return node.scrollTop;
        }
    }
    /**
     * @return {?}
     */
    getViewportHeight() {
        return (this.parent().innerHeight ||
            document.documentElement.clientHeight ||
            document.body.clientHeight);
    }
    /**
     * @return {?}
     */
    getDocumentHeight() {
        const /** @type {?} */ body = document.body;
        const /** @type {?} */ documentElement = document.documentElement;
        return Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);
    }
    /**
     * @param {?} elm
     * @return {?}
     */
    getElementPhysicalHeight(elm) {
        return Math.max(elm.offsetHeight, elm.clientHeight);
    }
    /**
     * @param {?} elm
     * @return {?}
     */
    getElementHeight(elm) {
        return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);
    }
    /**
     * @return {?}
     */
    getScrollerPhysicalHeight() {
        const /** @type {?} */ parent = this.parent();
        return parent === this.parent() || parent === document.body
            ? this.getViewportHeight()
            : this.getElementPhysicalHeight(parent);
    }
    /**
     * @return {?}
     */
    getScrollerHeight() {
        const /** @type {?} */ parent = this.parent();
        return parent === this.parent() || parent === document.body
            ? this.getDocumentHeight()
            : this.getElementHeight(parent);
    }
    /**
     * @param {?} currentScrollY
     * @return {?}
     */
    isOutOfBound(currentScrollY) {
        const /** @type {?} */ pastTop = currentScrollY < 0;
        const /** @type {?} */ scrollerPhysicalHeight = this.getScrollerPhysicalHeight();
        const /** @type {?} */ scrollerHeight = this.getScrollerHeight();
        const /** @type {?} */ pastBottom = currentScrollY + scrollerPhysicalHeight > scrollerHeight;
        return pastTop || pastBottom;
    }
    /**
     * @return {?}
     */
    handleScroll() {
        if (!this.scrollTicking) {
            this.scrollTicking = true;
            this.update();
        }
    }
    /**
     * @return {?}
     */
    handleResize() {
        if (!this.resizeTicking) {
            this.resizeTicking = true;
            this.setHeightOffset();
        }
    }
    /**
     * @return {?}
     */
    handleUnpin() {
        this.unpin.emit();
        this.state = 'unpinned';
        this.innerStyle.position = this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    }
    /**
     * @return {?}
     */
    handlePin() {
        this.pin.emit();
        this.state = 'pinned';
        this.innerStyle.position = this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    }
    /**
     * @return {?}
     */
    handleUnfix() {
        this.unfix.emit();
        this.state = 'unfixed';
        this.innerStyle.position = this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    }
    /**
     * @return {?}
     */
    update() {
        this.currentScrollY = this.getScrollY();
        if (!this.isOutOfBound(this.currentScrollY)) {
            const { action } = shouldUpdate(this.lastKnownScrollY, this.currentScrollY, this.disable, this.pinStart, this.downTolerance, this.upTolerance, this.state, this.height);
            if (action === 'pin') {
                this.handlePin();
            }
            else if (action === 'unpin') {
                this.handleUnpin();
            }
            else if (action === 'unfix') {
                this.handleUnfix();
            }
        }
        this.lastKnownScrollY = this.currentScrollY;
        this.scrollTicking = false;
    }
}
HeadroomComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-headroom',
                template: `
  <div [ngStyle]="wrapperStyle"
    [style.height.px]="wrapperHeight"
    class="headroom-wrapper {{ wrapperClassName }}"
  >
    <div #ref
      [ngStyle]="innerStyle"
      [@headroom]="{
        value: state,
        params: {
          duration: duration,
          easing: easing
        }
      }"
      [class]="innerClassName"
      [class.headroom]="true"
      [class.headroom--unfixed]="state === 'unfixed'"
      [class.headroom--unpinned]="state === 'unpinned'"
      [class.headroom--pinned]="state === 'pinned'"
      [class.headroom--unfixed]="state === 'unfixed'"
    >
      <ng-content></ng-content>
    </div>
  </div>
  `,
                animations: [
                    trigger('headroom', [
                        state('unfixed', style({
                            transform: 'translateY(0)',
                        })),
                        state('unpinned', style({
                            transform: 'translateY(-100%)',
                        })),
                        state('pinned', style({
                            transform: 'translateY(0px)',
                        })),
                        transition('unpinned <=> pinned', animate('{{ duration }}ms {{ easing }}')),
                    ]),
                ],
                preserveWhitespaces: false,
            },] },
];
/** @nocollapse */
HeadroomComponent.ctorParameters = () => [];
HeadroomComponent.propDecorators = {
    "wrapperClassName": [{ type: Input },],
    "innerClassName": [{ type: Input },],
    "innerStyle": [{ type: Input },],
    "wrapperStyle": [{ type: Input },],
    "disable": [{ type: Input },],
    "upTolerance": [{ type: Input },],
    "downTolerance": [{ type: Input },],
    "pinStart": [{ type: Input },],
    "calcHeightOnResize": [{ type: Input },],
    "duration": [{ type: Input },],
    "easing": [{ type: Input },],
    "pin": [{ type: Output },],
    "unpin": [{ type: Output },],
    "unfix": [{ type: Output },],
    "inner": [{ type: ViewChild, args: ['ref',] },],
    "parent": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class HeadroomModule {
}
HeadroomModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [HeadroomComponent],
                declarations: [HeadroomComponent],
            },] },
];
/** @nocollapse */
HeadroomModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { HeadroomModule, HeadroomComponent };
//# sourceMappingURL=ctrl-ngx-headroom.js.map
